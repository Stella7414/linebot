# -*- coding: utf-8 -*-
import os
import requests
import json
import emoji
from datetime import datetime
from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError
from linebot.models import MessageEvent, TextMessage, TextSendMessage, ImageSendMessage
from bs4 import BeautifulSoup
import re

app = Flask(__name__)

# ğŸš€ å¡«å…¥ä½ çš„ LINE Bot API Key
line_bot_api = LineBotApi('fuLwWAY1ZfgrgjGky0TyxYjmsiqA77KHI5ktQ/1YQsDLsIbhTo0nAyROjFZDn4IAwMFC++t9S09hlni42hvqtRyZFe1qQ3ptO6PJ8PsL95a/pjjlbovHxjv98jYGABcWtb6VjB2Gvaj7Z95NWD1tGAdB04t89/1O/w1cDnyilFU=')
handler = WebhookHandler('f2cb6bdd930ac1b56b53bfd69a0df898')

# ğŸš€ å¡«å…¥ä½ çš„ Google Places API Key
GOOGLE_PLACES_API_KEY = 'AIzaSyBqbjGjjpt3Bxo9RB15DE4uVBmoBRlNXVM'


# ğŸ“ Google Places API æŸ¥è©¢å‡½æ•¸ï¼ˆåŠ å…¥é¤å»³æ’åèˆ‡åœ–ç‰‡ï¼‰
def search_restaurants(location):
    url = "https://maps.googleapis.com/maps/api/place/textsearch/json"
    params = {
        "query": f"{location} é¤å»³",
        "key": GOOGLE_PLACES_API_KEY,
        "language": "zh-TW",
    }

    try:
        response = requests.get(url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        # å¦‚æœ API æ²’å›å‚³çµæœ
        if "results" not in data or not data["results"]:
            return "ğŸ˜¢ æ²’æœ‰æ‰¾åˆ°ç›¸é—œé¤å»³ï¼Œè«‹æ›å€‹é—œéµå­—è©¦è©¦çœ‹ï¼"

        # æŒ‰è©•åˆ†æ’åºï¼ˆç”±é«˜åˆ°ä½ï¼‰ä¸¦é¸å–å‰ 5 å
        restaurants = sorted(data["results"], key=lambda r: r.get("rating", 0), reverse=True)[:5]
        
        messages = []

        for index, r in enumerate(restaurants, start=1):
            name = r.get("name", "æœªçŸ¥é¤å»³")
            rating = r.get("rating", "ç„¡è©•åˆ†")
            address = r.get("formatted_address", "ç„¡åœ°å€è³‡è¨Š")
            business_status = r.get("business_status", "ç„¡ç‡Ÿæ¥­è³‡è¨Š")

            reply_text = (
                f"ğŸ† **{index}. {name}**\n"
                f"â­ è©•åˆ†ï¼š{rating}/5.0\n"
                f"ğŸ“ åœ°å€ï¼š{address}\n"
                f"ğŸ•’ ç‡Ÿæ¥­ç‹€æ³ï¼š{business_status}"
            )

            # æª¢æŸ¥æ˜¯å¦æœ‰åœ–ç‰‡
            photo_url = None
            if "photos" in r and r["photos"]:
                photo_reference = r["photos"][0]["photo_reference"]
                photo_url = f"https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference={photo_reference}&key={GOOGLE_PLACES_API_KEY}"

            # å›æ‡‰æ–‡å­—è¨Šæ¯
            messages.append(TextSendMessage(text=reply_text))

            # å›æ‡‰åœ–ç‰‡è¨Šæ¯ï¼ˆå¦‚æœæœ‰åœ–ç‰‡ï¼‰
            if photo_url:
                messages.append(ImageSendMessage(original_content_url=photo_url, preview_image_url=photo_url))

        return messages

    except requests.exceptions.RequestException as e:
        return [TextSendMessage(text=f"âŒ ç„¡æ³•ç²å–é¤å»³è³‡è¨Šï¼š{e}")]


# GoogleMapSpider æŸ¥è©¢ç›¸é—œé¤å»³çš„æ–¹æ³•
class GoogleMapSpider:
    def __init__(self):
        self.headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36"}
        self.store_id_url = "https://www.google.com.tw/maps/search/{store_name}"
        self.store_name_url = "https://www.google.com.tw/maps/place/data=!4m5!3m4!1s{store_id}!8m2!3d25.0564743!4d121.5204167?authuser=0&hl=zh-TW&rclk=1"
        self.comment_url = "https://www.google.com.tw/maps/rpc/listugcposts"

    def get_store_id(self, store_name):
        '''store_nameå¿…é ˆèˆ‡googleåœ°åœ–æœå°‹çµæœå®Œå…¨ä¸€è‡´, ä¾‹å¦‚: éš±å®¶æ‹‰éºµ å£«æ—åº—'''
        url = self.store_id_url.format(store_name=store_name)
        response = requests.get(url, headers=self.headers)
        soup = BeautifulSoup(response.text, "lxml")
        pattern = r'0x.{16}:0x.{16}'
        match = re.search(pattern, str(soup))
        store_id = match.group()

        return store_id

    def get_store_name(self, store_id):
        url = self.store_name_url.format(store_id=store_id)
        response = requests.get(url, headers=self.headers)
        soup = BeautifulSoup(response.text, "lxml")
        meta_list = soup.find_all('meta')
        store_name = []
        for i in meta_list:
            if '''itemprop="name"''' in str(i):
                store_name.append(re.search('".*Â·', str(i)).group()[1:-2])
        return store_name[0] if store_name else "æœªæ‰¾åˆ°å•†åº—åç¨±"

    def get_comment(self, store_id, page_count=1, sorted_by=2):
        next_token = ""
        commont_list = []
        for page in range(1, page_count + 1):
            print(f"ç¬¬ {page} é é–‹å§‹æŠ“å–")
            params = {
                "authuser": "0",
                "hl": "zh-TW",
                "gl": "tw",
                "pb": (
                    f"!1m6!1s{store_id}!6m4!4m1!1e1!4m1!1e3!2m2!1i10!2s"
                    f"{next_token}!"
                    f"5m2!1s0OBwZ4OnGsrM1e8PxIjW6AI!7e81!8m5!1b1!2b1!3b1!5b1!7b1!11m0!13m1!1e{sorted_by}"
                )
            }

            response = requests.get(self.comment_url, params=params, headers=self.headers)
            data = json.loads(emoji.demojize(response.text[4:]))
            next_token = data[1]
            commont_list.extend(data[2])
            if not next_token:
                break

        commont_dict_list = []
        for comment_data in commont_list:
            try:
                comment_date = comment_data[0][2][2][0][1][21][6][-1]
                comment_date = datetime(comment_date[0], comment_date[1], comment_date[2], comment_date[3]).strftime('%Y/%m/%d %H:%M:%S')
            except:
                comment_date = None

            try:
                comment_text = comment_data[0][2][-1][0][0]
            except:
                comment_text = None

            comment_info = {
                "è©•è«–è€…": comment_data[0][1][4][5][0],
                "è©•è«–è€…id": comment_data[0][0],
                "è©•è«–è€…ç‹€æ…‹": comment_data[0][1][4][5][10][0],
                "è©•è«–è€…ç­‰ç´š": comment_data[0][1][4][5][9],
                "ç•™è¨€æ™‚é–“": comment_data[0][1][6],
                "ç•™è¨€æ—¥æœŸ": comment_date,
                "è©•è«–": comment_text,
                "è©•è«–åˆ†æ•¸": comment_data[0][2][0][0]
            }
            commont_dict_list.append(comment_info)

        return commont_dict_list


# ğŸ”„ è™•ç†ä½¿ç”¨è€…ç™¼é€çš„è¨Šæ¯
@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    user_input = event.message.text.strip()

    if len(user_input) >= 2:  # é™åˆ¶æœ€å°å­—æ•¸ï¼Œé¿å…ç„¡æ•ˆæŸ¥è©¢
        results = search_restaurants(user_input)
    else:
        results = [TextSendMessage(text="âŒ è«‹è¼¸å…¥ **åŸå¸‚åç¨± + ç¾é£Ÿé¡å‹**ï¼ˆä¾‹å¦‚ï¼šã€Œå°åŒ—ç‡’è‚‰ã€ï¼‰ã€‚")]

    line_bot_api.reply_message(event.reply_token, results)


# ğŸ“Œ Line Bot Webhook è¨­å®š
@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers.get('X-Line-Signature', '')
    body = request.get_data(as_text=True)

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        abort(400)

    return 'OK'


# ğŸ”¥ å•Ÿå‹• Flask æ‡‰ç”¨ç¨‹å¼
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))
